# Gravitational-Search-Algorithm-GSA-
GSA — это алгоритм оптимизации, основанный на законе гравитации и массовых взаимодействиях. Этот алгоритм основан на ньютоновской гравитации.

## 1. Введение

В инженерной практике и прикладной математике нередко приходится искать глобальный минимум функции 

$$
f(x)\;\to\;\min_{x\in\Omega},
$$ 

где $\Omega$ — допустимое пространство поиска; $x^*$ — искомое глобально оптимальное решение.

Классические градиентные методы показывают высокую скорость сходимости лишь для выпуклых и гладких задач, но при наличии множества экстремумов, шумов и ограничений часто «застревают» в локальных минимумах. Особый интерес представляет Gravitational Search Algorithm (GSA): агенты-«частицы» перемещаются под действием сил, пропорциональных качеству решений, однако в высоких размерностях базовая версия GSA склонна к преждевременной сходимости.

Для её преодоления предложен Manifold-guided GSA (MGGSA), в котором перемещение агентов ограничено адаптивным субпространством $\mathcal{M}$, аппроксимирующим локальную геометрию уровней функции.

Цель — провести систематический сравнительный анализ GSA и MGGSA на стандартном наборе тестовых функций глобальной оптимизации.

---

## 2. Gravitational Search Algorithm (GSA)

GSA моделирует популяцию «тел» как систему масс, притягивающихся друг к другу по закону Ньютона. Каждое тело-агент одновременно играет две роли:

1. **Исследователь** (probe) — перемещается в пространстве поиска, «зондируя» поверхность функции.  
2. **Источник гравитации** — чем ниже значение $f$, тем массивнее агент и тем сильнее он притягивает соседей.

Пусть $x_i(t)$ — позиция $i$-го агента на итерации $t$. Сила, действующая со стороны агента $j$ на агент $i$ по координате $d$, задаётся как

$$
F_{ij}^d(t)
= G(t)\,\frac{M_i(t)\,M_j(t)}{R_{ij}(t)+\varepsilon}\,\bigl(x_j^d(t)-x_i^d(t)\bigr),
$$

где  
- $G(t)$ — гравитационная константа;  
- $M_i(t)$ — масса агента $i$, пропорциональная качеству решения;  
- $R_{ij}(t)$ — евклидово расстояние между агентами $i,j$;  
- $\varepsilon$ — малое число для избегания деления на ноль.  

Суммарная сила $F_i(t)$ даёт ускорение $a_i(t)=F_i(t)/M_i(t)$, после чего обновляются скорость и позиция агента.

---

## 3. Manifold-guided GSA (MGGSA)

В MGGSA движение агентов ограничено адаптивным подпространством (многообразием) $\mathcal{M}$, аппроксимирующим локальную геометрию уровней функции.

1. В окрестности центра $c$ (центроид лучших агентов) вычисляются $k$ наименьших собственных векторов $\{u_1,\dots,u_k\}$ гессиана функции.  
2. Сформировано многообразие
   
$$
\mathcal{M} = \mathrm{span}\{u_1,\dots,u_k\}.
$$  

4. Каждая параная сила $F_{ij}(t)$ сначала вычисляется как в GSA, затем проецируется на $\mathcal{M}$:
   
$$
\widetilde F_{ij}(t)
= P_{\mathcal{M}}\bigl(F_{ij}(t)\bigr).
$$

6. Актуализированные ускорение, скорость и позиция рассчитываются с учётом ортогональной демпфирующей компоненты, гасящей отклонения от $\mathcal{M}$.  

Проекцию пересчитывают каждые $T_p$ итераций для подстройки к меняющейся топологии.

---

## 4. Сравнительный анализ

### 4.1 Набор тестовых функций и параметры эксперимента

- **Функции-бенчмарки**:  
  - Sphere  
  - Rosenbrock  
  - Rastrigin  
  - Ackley  

- **Размерности**: $d=10,20,\dots,100$  
- **Число агентов**: $N=10,20,\dots,100$  
- **Максимум итераций**: $T_{\max}=5\cdot10^4$  
- **Число прогонов**: 50000 (разные начальные условия)

### 4.2 Метрики эффективности

1. **Абсолютная ошибка**
   
$$
\Delta = \bigl|f(x_{\text{best}})-f(x^*)\bigr|.
$$
   
3. **Среднее число итераций до порога точности**
   
$$
\overline{T} = \frac1M\sum_{m=1}^M T_m.
$$

5. **Среднее CPU-time**

$$
{\text{CPU}} = \frac1M\sum_{m=1}^M t_{\text{CPU},m}.
$$

### 4.3 Основные результаты

- **Точность (рис. 1)**  
  MGGSA показывает значительно более низкую среднюю ошибку при росте $d$, особенно на гладких функциях (Sphere, Ackley).  
- **Число итераций (рис. 3)**  
  Проекция на многообразие увеличивает число итераций в 1.6–4 раза в зависимости от задачи.  
- **Время работы (рис. 4)**  
  CPU-time для MGGSA растёт почти линейно с $d$, оставаясь в 3–5 раз больше, чем у GSA при малых $d$, и достигая десятков секунд при $d\gtrsim50$.  


Зависимость средней абсолютной ошибки от размерности $d$ (логарифмическая шкала по оси $Y$).  

![изображение](https://github.com/user-attachments/assets/1df38a29-6779-4908-b5f7-560250191884)


Зависимость средней абсолютной ошибки от числа агентов $N$.  

![изображение](https://github.com/user-attachments/assets/5fc5da99-c5cd-4555-81b9-ecb35f041799)

Распределения числа итераций $T$ для достижения заданного порога точности.  

![изображение](https://github.com/user-attachments/assets/d9ad1d06-498a-4b14-b34c-9fc31f4b94d3)


Среднее CPU-time одного запуска в зависимости от $d$ (а) и $N$ (б).

![изображение](https://github.com/user-attachments/assets/76d42e72-e8c9-445b-aa13-2771da173a41)

---

## 5. Заключение

Накладные расходы на проекцию и работу с многообразием приводят к увеличению числа итераций и времени работы MGGSA, но обеспечивают заметный прирост точности при высокой размерности. Рекомендуется гибридный подход: сначала быстрый прогон GSA для грубой оценки, затем MGGSA для высокоточного решения при критичных требованиях к качеству.

---

## 6. Запуск проекта

```
$ run.sh
```
